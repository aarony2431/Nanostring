---
title: "CynoPlexAll"
author: "Oliver Dansereau"
date: "10/12/2020"
output: html_document
---
##1. Load packages, set directories, establish parameters
```{r echo = FALSE}

##load packages

suppressPackageStartupMessages({

        library(NanoStringQCPro)
        library(NanoStringNorm)
        library("pheatmap")
        library("RColorBrewer")
        library("PoiClaClu")
        library(ggplot2)
        library(vsn)
        library(gplots)
        library(hexbin)
        library(gtools)
        library(dplyr)
        library(stringr)
        library(tidyr)
        library(ggpubr)
        library(aod)
        library(boot)
        library(caret)
        library(psych)
        library(e1071)
        library(tidyverse)
        library(ROSE)
        library(car)
})

##Define Experiment Name
exp <- "20201221_Cyno6"

##Define hs_genes
hs_genes <- c('IPO13_1', 'RER1_1','GHITM_1','TMBIM6_1','GTF2B_1','TXNIP_1','ENSMFAG00000010720_1')

##Define gene list file name
gn_file <- "NanostringMasterList.csv"

#Set main working directory and sub directories, create if they do not exist
{
mainDir <- paste0("P:\\Research\\Lab\\data transfer\\Oliver\\Nanostring\\Analysis\\20201221_Cyno6")
                
        expression_dir <- paste0(mainDir, "\\Expression")
                ifelse(!dir.exists(file.path(mainDir, "Expression")), dir.create(file.path(mainDir, "\\Expression")), FALSE)
        qc_dir <- paste0(mainDir, "\\QC")
                ifelse(!dir.exists(file.path(mainDir, "QC")), dir.create(file.path(mainDir, "QC")), FALSE)
        data_dir <- paste0(mainDir, "\\data")
                ifelse(!dir.exists(file.path(mainDir, "data")), dir.create(file.path(mainDir, "\\data")), FALSE)
                
        gene_list_dir <- "C:\\Data_Analysis\\Nanostring\\Gene_Lists"
}


##Define Heatmap Function
heat <- function(dat, sym, title, cls){
  marg = c(10,8) 
  coldeg = 45
  colramp = colorRampPalette(brewer.pal(11, "RdBu"))(256)
  colramp = rev(colramp)
 
  set.seed(1)
  d <- dist(dat, method = "euclidean")
  fit <- hclust(d, method="ward.D2") #cluster data
  
  if(cls == "T"){
    set.seed(1)
    d_c <- dist(t(dat), method = "euclidean")
    fit_c <- hclust(d_c, method="ward.D2") #cluster data
    set.seed(1)
    heatmap.2(as.matrix(dat), Rowv = as.dendrogram(fit), Colv = as.dendrogram(fit_c), 
              dendrogram = "both", col = colramp, scale = "none", 
              symm=sym,symkey=sym,symbreaks=sym, key = TRUE, keysize = 1.5, 
              density.info = 'histogram', densadj = 0.25, cexCol = 1.2,
              cexRow = 1, margins = marg, srtCol = coldeg, trace = "none",
              main = title)
  }else{
    set.seed(1)
    heatmap.2(as.matrix(dat), Rowv = as.dendrogram(fit), Colv = FALSE, 
              dendrogram = "row", col = colramp, scale = "none", 
              symm=sym,symkey=sym,symbreaks=sym, key = TRUE, keysize = 1.5, 
              density.info = 'histogram', densadj = 0.25, cexCol = 1.2,
              cexRow = 1, margins = marg, srtCol = coldeg, trace = "none",
              main = title)
  }
}
```

##2. Normalize data to HKG
```{r,echo=FALSE}
##read nsolver normalized data
{
setwd(data_dir)
data <- read.csv(paste0("20201221_Cyno6_Analysis_Norm.csv"), row.names = 1)
rawData <- read.csv("20201221_Cyno6_Analysis_Raw.csv")
plate2 <- read.csv("20201219_PSE_Cyno6_Platemap.csv", row.names = 1)
plate1 <- read.csv("20201210_PSE_Cal_Cyno6_Platemap.csv", row.names = 1)
qpcrKD <- read.csv("qPCR_KD_Data.csv")
setwd(gene_list_dir)
gnList <- read.csv(gn_file, row.names = 1, header = TRUE)

}

names <- row.names(set1)

{
        setwd(expression_dir)
        write.csv(names,"names.csv")
}
##remove nonexistent probes

#collate data
{
set1 <- as.data.frame(t(data[,grepl("20201211", colnames(data))]))
        set1 <- merge(plate1,set1, by = 0)
set2 <- as.data.frame(t(data[,grepl("20201219", colnames(data))]))
        set2 <- merge(plate2,set2, by = 0)
pset <- rbind(set1,set2)
}

#subset tissue types for normalization
{
muscleSet <- pset[pset$Tissue %in% c("GAS", "QUAD","LD","Bicep"),]
}
##. Sample Content Normalization
              ##  - Geometric mean is taken of all housekeeping samples per lane. (Done for every lane, after part a. and b.)
              ##  - A global arithmetic average is taken of all the lanes Geomtric means (so average of all values from i.)
              ##  - A lane specific scaling factor is generated by taking (global arithmetic average/lane specific geomean) (so part ii./part i.)
              ##  - This Scaling factor is multiplied to its respective lane for endogenous and housekeeping samples

##Scale Muscle to HKG
{
##define muscle scaling factor
        {
        muscleSetHKG <- muscleSet
                muscleSetHKG[,1:7] <- NULL
                muscleSetHKG <- as.data.frame(t(muscleSetHKG))
                muscleSetHKG <- muscleSetHKG[row.names(muscleSetHKG) %in% hs_genes,]
                
        muscleSetHKG_gmean <- sapply(muscleSetHKG,geometric.mean)
                muscleSetHKG_gmean_avg <- mean(muscleSetHKG_gmean)
        
        muscleSetScale <- sapply(muscleSetHKG_gmean, function(x) muscleSetHKG_gmean_avg/x)
        }

 
#Scale Data
        {
        l <- length(muscleSet)
                muscleNorm <- muscleSet
                muscleName <- muscleNorm[,1:7]
                muscleNorm <- muscleNorm[,8:l]
                muscleNorm <- as.data.frame(t(muscleNorm))
                muscleNorm <- muscleNorm*muscleSetScale[col(muscleNorm)]
                muscleNorm <- as.data.frame(t(muscleNorm))
                muscleNorm <- cbind(muscleName,muscleNorm)
        }
}

#seperate Muscle
{
bicep <- muscleNorm[muscleNorm$Tissue == "Bicep",]
        bicep <- bicep[bicep$Load == 100,]
quad <- muscleNorm[muscleNorm$Tissue == "QUAD",]
gastroc <- muscleNorm[muscleNorm$Tissue == "GAS",]
ld <- muscleNorm[muscleNorm$Tissue == "LD",]
}

#calculate DMPK1 KD
{
bicepNorm <- bicep[bicep$Animal.Number %in% c(1001,1002,1501,1502),]
        bicepDmpkAverage <- mean(bicepNorm$DMPK_1)
        bicep$DMPK_KD <- bicep$DMPK_1/bicepDmpkAverage
        
quadNorm <- quad[quad$Animal.Number %in% c(1001,1002,1501,1502),]
        quadDmpkAverage <- mean(quadNorm$DMPK_1)
        quad$DMPK_KD <- quad$DMPK_1/quadDmpkAverage
        
gastrocNorm <- gastroc[gastroc$Animal.Number %in% c(1001,1002,1501,1502),]
        gastrocDmpkAverage <- mean(gastrocNorm$DMPK_1)
        gastroc$DMPK_KD <- gastroc$DMPK_1/gastrocDmpkAverage
        
ldNorm <- ld[ld$Animal.Number %in% c(1001,1002,1501,1502),]
        ldDmpkAverage <- mean(ldNorm$DMPK_1)
        ld$DMPK_KD <- ld$DMPK_1/ldDmpkAverage
}

muscleKD_set <- rbind(bicep,quad,gastroc,ld)

muscleComp <- merge(qpcrKD, muscleKD_set, by = "Sample")

{
        setwd(expression_dir)
        write.csv(muscleComp, "MuscleComp.csv")
}


```


##3. Gene Clustering
```{r}
library("ggfortify")

ctrlNames <- c("POS_1","POS_2","POS_3","POS_4","POS_5","POS_6","POS_7","POS_8","NEG_1","NEG_2","NEG_3","NEG_4","NEG_5","NEG_6","NEG_7","NEG_8")

dmpkRemove <- c("DMPK_1","DMPK_2","DMPK_3","DMPK_KD","Quality", "ENSMFAG00000035335_1")

dupProb <- c("CD63_1","KRT14_3","MEST_2","TFRC_2","TRIM54_2","TRIM55_2","TRIM63_2")
#Structure data, keep smaples of interest
{
muscleClusterSet <- muscleNorm[!colnames(muscleNorm) %in% ctrlNames]
        muscleClusterSet <- muscleClusterSet[!muscleClusterSet$Timepoint == "dm7",]
        muscleClusterSet <- muscleClusterSet[!muscleClusterSet$Group %in% c(1,5),]
        muscleClusterSet <- muscleClusterSet[!colnames(muscleClusterSet) %in% hs_genes]
        muscleClusterSet <- muscleClusterSet[!colnames(muscleClusterSet) %in% dupProb]
                muscleClusterSet <- muscleClusterSet[!duplicated(muscleClusterSet$Sample.ID),]
                rownames(muscleClusterSet) <- muscleClusterSet$Sample.ID
                        muscleClusterSet <- muscleClusterSet[!row.names(muscleClusterSet) == "TA_d28_7_3",]
                        
        quad <- muscleClusterSet[muscleClusterSet$Muscle == "QUAD",] 
        ta <- muscleClusterSet[muscleClusterSet$Muscle == "TA",]
        gas <- muscleClusterSet[muscleClusterSet$Muscle == "GAS",]
}

{
tmuscleClusterSet <- muscleClusterSet[!colnames(muscleClusterSet) %in% dmpkRemove]
        l <- length(tmuscleClusterSet)
        tmuscleClusterSet <- tmuscleClusterSet[,6:l]
        tmuscleClusterSet <- t(tmuscleClusterSet)
        tmuscleClusterSet <- log10(tmuscleClusterSet)
        
pcaMuscleNorm <- prcomp(tmuscleClusterSet, scale.=TRUE)
        autoplot(pcaMuscleNorm, label = TRUE, title = "PCA log10 Muscle, all genes")
}

{
q <- length(quad)
pca <- quad[,6:q]
        pca <- pca[!colnames(pca) %in% dmpkRemove]
        pca <- log10(pca)
pca <- prcomp(pca, scale.=TRUE)
        quad$Quality <- as.factor(quad$Quality)
        autoplot(pca, label = TRUE, data = quad, colour = "Quality", main = "QUAD PCA") + scale_color_brewer(palette = "Set1")
}
{
q <- length(ta)
pca <- ta[,6:q]
        pca <- pca[!colnames(pca) %in% dmpkRemove]
        pca <- log10(pca)
pca <- prcomp(pca, scale.=TRUE)
        ta$Quality <- as.factor(ta$Quality)
        autoplot(pca, label = TRUE, data = ta, colour = "Quality", main = "TA PCA") + scale_color_brewer(palette = "Set1")
}
{
q <- length(gas)
pca <- gas[,6:q]
        pca <- pca[!colnames(pca) %in% dmpkRemove]
        pca <- log10(pca)
pca <- prcomp(pca, scale.=TRUE)
        gas$Quality <- as.factor(gas$Quality)
        autoplot(pca, label = TRUE, data = gas, colour = "Quality", main = "GAS PCA") + scale_color_brewer(palette = "Set1")
}


{
cmuscleClusterSet <- muscleClusterSet[!colnames(muscleClusterSet) %in% dmpkRemove]
        l <- length(cmuscleClusterSet)
        cmuscleClusterSet <- t(cmuscleClusterSet[,6:l])
hclust_matrix <- cmuscleClusterSet %>% 
  # transpose the matrix so genes are as columns
  t() %>% 
  # apply scalling to each column of the matrix (genes)
  scale() %>% 
  # transpose back so genes are as rows again
  t()
}

gene_dist <- dist(hclust_matrix)

gene_hclust <- hclust(gene_dist, method = "complete")

# The default `plot()` function can be used to produce a simple dendrogram
plot(gene_hclust, hang = -1, cex = 0.6)

{
gene_cluster <- cutree(gene_hclust, k = 10) %>% 
  # turn the named vector into a tibble
  enframe() %>% 
  # rename some of the columns
  rename(gene = name, cluster = value)

head(gene_cluster)
}
gnListMerge <- gnList
gnListMerge$gene <- row.names(gnList)
geneClusterMerge <- merge(gnListMerge, gene_cluster, by ="gene")


```
##Panel Analysis

```{r}
{
musclePanel <- (muscleNorm)
        musclePanel <- musclePanel[!duplicated(musclePanel$Sample.ID),]
        rownames(musclePanel) <- musclePanel$Sample.ID
                musclePanel <- musclePanel[!row.names(musclePanel) == "TA_d28_7_3",]
                sampleIndex <- musclePanel[,1:5]
                sampleIndex$Quality <- musclePanel$Quality
        musclePanel <- t(musclePanel[,6:103])
        musclePanel <- merge(gnList, musclePanel, by = 0)
                rownames(musclePanel) <- musclePanel$Row.names
muscleCorr <- muscleNorm[!muscleNorm$Group == 1,]        
panelNames <- unique(musclePanel$Panel)
}
for (i in 1:length(panelNames)){
        panel <- panelNames[i]
        poi <- musclePanel[musclePanel$Panel == panel,]
                l <- length(poi)
        poiGmean <- sapply(poi[,4:l], geometric.mean)
                names(poiGmean) <- colnames(poi[,4:l])
        poiGmean <- as.data.frame(poiGmean) 
                poiGmean <- merge(sampleIndex,poiGmean, by = 0)
                poigmean <- poiGmean[poiGmean$Muscle == "TA",]
                poigmean <- poigmean[!poigmean$Group == 1,]
                        poiA <- poigmean[poigmean$Timepoint == "d14",]
                                poiA$Number <- seq.int(nrow(poiA))
                        poiB <- poigmean[poigmean$Timepoint == "d28",]
                                poiB$Number <- seq.int(nrow(poiB))
                                
                        graph <- rbind(poiA, poiB)
                                graph <- graph[order(graph$Number),]
        print(ggbarplot(graph, x = "Sample.ID", y = "poiGmean", 
                        xlab = "Sample ID", 
                        ylab = "Gmean Normalized Counts", 
                        title = panel, fill = "Timepoint", 
                        color = "Timepoint",palette = "jco", 
                        xtickslab.rt = 90, 
                        label = ifelse(graph$Quality == 1, "Q","")))
        row.names(graph) <- graph$Row.names
                
        panelCorr <- as.data.frame(t(musclePanel))
                dmpkVal <- as.data.frame(panelCorr$DMPK_1, row.names = row.names(panelCorr))
                graph$Row.names <- NULL
        panelCorrDmpk <- merge(graph, dmpkVal, by = 0)
                panelCorrDmpk$`panelCorr$DMPK_1` <- as.numeric(panelCorrDmpk$`panelCorr$DMPK_1`)
        title <- paste(panel, "Correlation")
        print(ggscatter(panelCorrDmpk, x = "poiGmean", y = "panelCorr$DMPK_1",
                                add = "reg.line",                         # Add regression line
                                palette = "jco",           # Color by groups "cyl"
                                                            # Change point shape by groups "cyl"
                                fullrange = TRUE,                         # Extending the regression line
                                rug = TRUE,
                                title = title                              # Add marginal rug
                                )+
                                        stat_cor(method = "pearson", label.x = 3, label.y = 30))
}

for (i in 1:length(panelNames)){
        panel <- panelNames[i]
        poi <- musclePanel[musclePanel$Panel == panel,]
                l <- length(poi)
        poiGmean <- sapply(poi[,4:l], geometric.mean)
                names(poiGmean) <- colnames(poi[,4:l])
        poiGmean <- as.data.frame(poiGmean) 
                poiGmean <- merge(sampleIndex,poiGmean, by = 0)
                poigmean <- poiGmean[poiGmean$Sample.ID %in% c("QUAD_d56_6_6001_Surgical","QUAD_d56_6_6001_Core Needle"),]
                        graph <-poigmean
                                
        print(ggbarplot(graph, x = "Sample.ID", y = "poiGmean", 
                        xlab = "Sample ID", 
                        ylab = "Gmean Normalized Counts", 
                        title = panel, fill = "Timepoint", 
                        color = "Timepoint",palette = "jco", 
                        label = ifelse(graph$Quality == 1, "Q","")))
}

panelNames <- musclePanel$Row.names
for (i in 1:length(panelNames)){
        panel <- panelNames[i]
        poi <- musclePanel[musclePanel$Row.names == panel,]
                l <- length(poi)
        poiGmean <- sapply(poi[,4:l], geometric.mean)
                names(poiGmean) <- colnames(poi[,4:l])
        poiGmean <- as.data.frame(poiGmean) 
                poiGmean <- merge(sampleIndex,poiGmean, by = 0)
                poigmean <- poiGmean[poiGmean$Muscle == "TA",]
                poigmean <- poigmean[!poigmean$Group == 1,]
                poiA <- poigmean[poigmean$Timepoint == "d14",]
                                poiA$Number <- seq.int(nrow(poiA))
                        poiB <- poigmean[poigmean$Timepoint == "d28",]
                                poiB$Number <- seq.int(nrow(poiB))
                                
                        graph <- rbind(poiA, poiB)
                                graph <- graph[order(graph$Number),]
        print(ggbarplot(graph, x = "Sample.ID", y = "poiGmean", 
                        xlab = "Sample ID", 
                        ylab = "Normalized Counts", 
                        title = panel, fill = "Timepoint", 
                        color = "Timepoint",palette = "jco", 
                        xtickslab.rt = 90, 
                        label = ifelse(graph$Quality == 1, "Q","")))
        
}



panelNames <- musclePanel$Row.names
for (i in 1:length(panelNames)){
        panel <- panelNames[i]
        poi <- musclePanel[musclePanel$Row.names == panel,]
                l <- length(poi)
        poiGmean <- sapply(poi[,4:l], geometric.mean)
                names(poiGmean) <- colnames(poi[,4:l])
        poiGmean <- as.data.frame(poiGmean) 
                poiGmean <- merge(sampleIndex,poiGmean, by = 0)
                poigmean <- poiGmean[poiGmean$Muscle == "TA",]
                poigmean <- poigmean[!poigmean$Group == 1,]
                poiA <- poigmean[poigmean$Timepoint == "d14",]
                                poiA$Number <- seq.int(nrow(poiA))
                        poiB <- poigmean[poigmean$Timepoint == "d28",]
                                poiB$Number <- seq.int(nrow(poiB))
                                
                        graph <- rbind(poiA, poiB)
                                graph <- graph[order(graph$Number),]
        print(ggbarplot(graph, x = "Sample.ID", y = "poiGmean", 
                        xlab = "Sample ID", 
                        ylab = "Normalized Counts", 
                        title = panel, fill = "Timepoint", 
                        color = "Timepoint",palette = "jco", 
                        xtickslab.rt = 90, 
                        label = ifelse(graph$Quality == 1, "Q","")))
}
for (i in 1:length(panelNames)){
        goi <- panelNames[i]
        print(ggscatter(muscleCorr, x = goi, y = "DMPK_1",
                                add = "reg.line",                         # Add regression line
                                palette = "jco",           # Color by groups "cyl"
                                title = goi,                            # Change point shape by groups "cyl"
                                fullrange = TRUE,                         # Extending the regression line
                                rug = TRUE,                              # Add marginal rug
                                )+
                                        stat_cor(method = "pearson"))
}
```



##Logistic Regression
```{r}
##SAVE?
saveit <- FALSE

##Subset and organize data for Logit
{
logitSet <- muscleNorm
        logitSet <- logitSet[!colnames(logitSet) %in% ctrlNames]
        logitSet <- logitSet[!duplicated(logitSet$Sample.ID),]
                row.names(logitSet) <- logitSet$Sample.ID
                        logitSet <- logitSet[!row.names(logitSet) == "TA_d28_7_3",]
                l <- length(logitSet)-2
                logitSetL <- log10(logitSet[,6:l])
                logitSet[,6:l] <- NULL
                logitSet$PredictedQuality <- NA
                logitSet <- cbind(logitSet,logitSetL)
                logitSet$Quality <- as.factor(logitSet$Quality)
                pcaData <- logitSet
                muscleDE <- logitSet
}

#Pull dm7 data
{
dm7Set <- logitSet[logitSet$Timepoint == "dm7",]
        logitSet <- logitSet[!logitSet$Timepoint == "dm7",]
        logitSet <- logitSet[!logitSet$Group %in% c(1,5),]
}

##Compare to qPCR data
{
cynoQ <- cyno4Qpcr
        row.names(cynoQ) <- cynoQ$Sample.ID
        cynoQ$Sample.ID <- NULL
qLogitSet <- as.data.frame(logitSet$DMPK_KD)
        row.names(qLogitSet) <- row.names(logitSet)
        qLogitSet <- qLogitSet*100
qComp <- merge(cynoQ, qLogitSet, by = 0)

qCorRes <- cor(qComp$qpcr_Expression,qComp$`logitSet$DMPK_KD`)

if (saveit == TRUE){
                setwd(expression_dir)
                write.csv(qComp, "Cyno4_qPCR_Comp.csv")
        } else {}

cyno5Q <- cyno5Qpcr

q5Comp <- merge(cyno5Q,qLogitSet, by = 0)

qCorRes5 <- cor(q5Comp$qPCR.expression,q5Comp$`logitSet$DMPK_KD`)

}


##Correlate genes with DMPK1
{
corrSet <- logitSet
c <- length(corrSet)
corRes <- cor(corrSet$DMPK_1, corrSet$CS_1)
for (i in 9:c){
        corTemp <- as.data.frame(cor(corrSet$DMPK_1, corrSet[i]))
        corRes <- cbind(corRes, corTemp)
        rm(corTemp)
        }


corRes[1] <- NULL
corRes <- as.data.frame(t(corRes))
corRes <- abs(corRes)
corRes <- corRes[order(corRes$V1, decreasing = TRUE),, drop = FALSE]

corResSubset <- as.data.frame(corRes[corRes$V1 > .5,, drop = FALSE])
corResSubset <- as.data.frame(corResSubset[corResSubset$V1 < .95,, drop = FALSE])

        genesCor <- row.names(corResSubset)
                genesCor <- genesCor[!genesCor %in% "SSB_1"]
                genesCor <- append(genesCor, "Quality")
}

##Define Training vs Test Set
{
train <- logitSet[!logitSet$Timepoint %in% c("d56", "d84"),]
test <- logitSet[logitSet$Timepoint %in% c("d56", "d84"),] 
}



get_best_result = function(caret_fit) {
  best = which(rownames(caret_fit$results) == rownames(caret_fit$bestTune))
  best_result = caret_fit$results[best, ]
  rownames(best_result) = NULL
  best_result
}

##Build model and predict using MYH3_2
{
set.seed(1)
logit <- glm(Quality ~ MYH3_2, data = train, family = binomial("logit"))      
        summary(logit)
        
test$PredictedQuality <- predict(logit, newdata = test, type = "response")

roc.curve(test$Quality, test$PredictedQuality)
{
pcaL <- test[,colnames(test) %in% c("MYH8_2", "MYH3_2")]
        pcaL <- prcomp(pcaL, scale.=TRUE)
        autoplot(pcaL, label = FALSE, data = test, colour = "Quality", main = "PCA, MYH3 MYH8") + scale_color_brewer(palette = "Set1")
}  

        if (saveit == TRUE){
                setwd(expression_dir)
                write.csv(test, "LogitPrediction_MYH3_Cyno5.csv")
        } else {}
}
## K-fold CV
{
set.seed(1)
k.train.control <- trainControl(method = "cv", number = 9)
kmodel <- train(Quality ~MYH3_2, data = train, method = "glm",
                    trControl = k.train.control)
print(kmodel)
}

##Subset for Elnet
{
rm <- c("DMPK_1","DMPK_2","DMPK_3","DMPK_KD","PredictedQuality")
l <- length(train)
train2 <- train[,6:l]
        train2 <- train2[!colnames(train2) %in% rm]
        train2 <- train2[!colnames(train2) %in% hs_genes]
test2 <- test[,6:l]
        test2 <- test2[!colnames(test2) %in% rm]
        test2 <- test2[!colnames(test2) %in% hs_genes]
fullSet <- rbind(train2,test2)
        
}  

##Build Elastic Net model 
{
set.seed(42)
cv_5 = trainControl(method = "cv", number = 12)
elnet <- train(Quality ~., 
               data = fullSet,
               method = "glmnet",
               trControl =cv_5,
               tuneLength = 20)
elnet

get_best_result(elnet)
elnetimp <- varImp(elnet)
elnetimp <- elnetimp$importance
elnetimp <- elnetimp[order(-elnetimp), , drop = FALSE]
elnetimp
}


##Build and test Logit Model with MYH3_2, PON2, BTG1, and CS1
{
set.seed(1)
logit <- glm(Quality ~ MYH3_2 + PON2_1 + BTG1_1 + CS_1, data = train, family = binomial("logit"))      
        summary(logit)
print(vif(logit))
plot(logit, which = 4, id.n = 3)
test$PredictedQuality <- predict(logit, newdata = test, type = "response")
dm7Set$PredictedQuality <- predict(logit, newdata = dm7Set, type = "response")

if (saveit == TRUE){
                setwd(expression_dir)
                write.csv(dm7Set, "LogitPrediction_MYH3_BTG1_CS_PON_dm7.csv")
        } else {}

pred <- c("MYH3_2", "PON2_1", "BTG1_1", "CS_1","PredictedQuality")
predictors <- c("MYH3_2", "PON2_1", "BTG1_1", "CS_1")
mydata <- test[,colnames(test) %in% pred]
mydata <- mydata %>%
  mutate(logit = log(PredictedQuality/(1-PredictedQuality))) %>%
  gather(key = "predictors", value = "predictor.value", -logit)

print(ggplot(mydata, aes(logit, predictor.value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~predictors, scales = "free_y")
)
{
pcaL <- test[,colnames(test) %in% c("BTG1_1", "MYH3_2", "CS_1", "PON2_1")]
        pcaL <- prcomp(pcaL, scale.=TRUE)
        print(autoplot(pcaL, label = FALSE, data = test, colour = "Quality", main = "PCA: MYH3 BTG1 CS PON2") + scale_color_brewer(palette = "Set1"))
}  
{
set.seed(28)
k.train.control <- trainControl(method = "cv", number = 12)
kmodel <- train(Quality ~ BTG1_1 + PON2_1 + MYH3_2, data = train, method = "glm",
                    trControl = k.train.control)
print(kmodel)
        if (saveit == TRUE){
                setwd(expression_dir)
                write.csv(test, "LogitPrediction_MYH3_BTG1_CS_PON_Cyno5.csv")
        } else {}
}


{
        cyno5CNB <- test[grepl("Core Needle",row.names(test)),]
        cyno5S <- test[grepl("Surgical",row.names(test)),]
        
        if (saveit == TRUE){
                setwd(expression_dir)
                write.csv(cyno5CNB, "cyno5CNB.csv")
                write.csv(cyno5S, "cyno5S.csv")
        } else {}
}






{
set.seed(42)
cv_5 = trainControl(method = "cv", number = 12)
elnet <- train(Quality ~ MYH3_2 + PON2_1 + CS_1 + BTG1_1, 
               data = train,
               method = "glmnet",
               trControl =cv_5,
               tuneLength = 20)
elnet
test$PredictedQuality <- predict(elnet, test, type = "prob")


setwd(expression_dir)
#write.csv(test, "ElasticNetPredicton_Cyno5.csv")
}














{
set.seed(42)
cv_5 = trainControl(method = "cv", number = 5)
elnet <- train(Quality ~ AGO2_1 + PON2_1 + CS_1 + TRIM55_1 + BTG1_1 + GPX3_1, 
               data = train,
               method = "glmnet",
               trControl =cv_5,
               tuneLength = 10)
elnet
test$PredictedQuality <- predict(elnet, test, type = "prob")
#roc.curve(test$Quality,test$PredictedQuality$1)

setwd(expression_dir)
#write.csv(test, "ElasticNetPredicton.csv")
}











{
pcaL <- logitSet[,colnames(logitSet) %in% c("AGO2_1", "PON2_1", "CS_1", "TRIM55_1", "BTG1_1", "GPX3_1")]
        pcaL <- prcomp(pcaL, scale.=TRUE)
        autoplot(pcaL, label = FALSE, data = logitSet, colour = "Quality", main = "PCA, MYH3 BTG1") + scale_color_brewer(palette = "Set1")
}        

{
pcaL <- logitSet[,9:88]
        pcaL <- prcomp(pcaL, scale.=TRUE)
        autoplot(pcaL, label = FALSE, data = logitSet, colour = "Quality", main = "PCA, MYH3 BTG1") + scale_color_brewer(palette = "Set1")
} 
                
#rocChart(test$Quality, test$PredictedQuality)
}


ggline(test, "DMPK_KD", "Sample.ID")















##Random Forest
library(randomForest)
{
set.seed(123)        
rfClassifier <- randomForest(Quality ~ ., data = fullSet, mytry = 8, important = TRUE)      
        
rffimp <- varImp(rfClassifier)
rffimp <- rffimp[order(-rffimp), , drop = FALSE]

print(rffimp)

test$PredictedQuality <- NULL
set.seed(123)        
rfClassifier <- randomForest(Quality ~ ., data = train2, mytry = 8, important = TRUE)
predicted <- predict(rfClassifier, test2, type = "prob")        
roc <- cbind(test2$Quality, predicted[,1])
roc.curve(roc[,1],roc[,2])

set.seed(123)        
rfClassifier <- randomForest(Quality ~ BTG1_1 + CD63_1 + TRIM55_1 + CTSS_1 + MYH3_2 + COX6A2_1, data = train, ntree = 10000, mytry = 8, important = TRUE)
test$PredictedQuality <- predict(rfClassifier, test, type = "prob")        
roc <- cbind(test2$Quality, predicted[,1])
roc.curve(roc[,1],roc[,2])

setwd(expression_dir)
write.csv(test, "rffPrediction.csv")
}
{
train <- logitSet[logitSet$Muscle %in% c("GAS", "TA"),]
test <- logitSet[logitSet$Muscle %in% c("QUAD"),] 
}

##Elastic Net
{
set.seed(42)
cv_5 = trainControl(method = "cv", number = 5)
elnet <- train(Quality ~., 
               data = fullSet,
               method = "glmnet",
               trControl =cv_5,
               tuneLength = 10)
elnet
}
get_best_result = function(caret_fit) {
  best = which(rownames(caret_fit$results) == rownames(caret_fit$bestTune))
  best_result = caret_fit$results[best, ]
  rownames(best_result) = NULL
  best_result
}

get_best_result(elnet)
elnetimp <- varImp(elnet)
elnetimp <- elnetimp$importance
elnetimp <- elnetimp[order(-elnetimp), , drop = FALSE]
print(elnetimp)
{
set.seed(42)
cv_5 = trainControl(method = "cv", number = 5)
elnet <- train(Quality ~ AGO2_1 + PON2_1 + CS_1 + TRIM55_1 + BTG1_1 + GPX3_1, 
               data = train,
               method = "glmnet",
               trControl =cv_5,
               tuneLength = 10)
elnet
test$PredictedQuality <- predict(elnet, test, type = "prob")
#roc.curve(test$Quality,test$PredictedQuality$1)

setwd(expression_dir)
write.csv(test, "ElasticNetPredicton.csv")
}

        
        
##Stepwise        
#stepwiseLogit <- glm(Quality ~., data = train2, family = binomial)        
        
#step.Logit <- step(stepwiseLogit, direction = "both", trace = FALSE)
        
#summary(step.Logit)        
{
train <- logitSet[logitSet$Muscle %in% c("GAS", "TA"),]
test <- logitSet[logitSet$Muscle %in% c("QUAD"),] 
}        

set.seed(1)
logit <- glm(Quality ~ CS_1 + CTSS_1 + LUM_1 + LY6D_1 + MYC_1 + MYH3_2, data = train, family = binomial)      
        summary(logit)
        
test$PredictedQuality <- predict(logit, newdata = test, type = "response")
{
set.seed(1)
k.train.control <- trainControl(method = "cv", number = 12)
kmodel <- train(Quality ~ CS_1 + CTSS_1 + LUM_1 + LY6D_1 + MYC_1 + MYH3_2, data = logitSet, method = "glm",
                    trControl = k.train.control)
print(kmodel)
} 
#roc.curve(test$Quality, test$PredictedQuality)


```

